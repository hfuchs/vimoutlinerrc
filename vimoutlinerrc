" 2009-08-11, Created by Hagen Fuchs <code@hfuchs.net>
"
" The definitions here define a complete link-suite (whatever /that/ is)
" for Vimoutliner.  To define a target, just place square brackets
" around it: '[target]'.  To link to it, simply write '[-> target]' or
" just '[> target]' and hit '<localleader>j'.  Nifty, I think.
"
" In addition, there's a slightly hacky autocommand definition here that
" I need to protect myself from the constant re-evaluation of foldexpr.


" --- Command Bindings
"  ,,j  -  Jump from origin to target
nmap <buffer> <localleader>j :call JumpToTargetID()<CR>

" 2012-03-16, Autocommand to update folds on /serious/ idle time (one
" hour).
set updatetime=3600000
autocmd CursorHold * call SwitchFoldmethod()


" --- Function Definitions
" Hint: Reload in running Vimoutliner session with ':source ~/.vimoutlinerrc'.

" SwitchFoldmethod {{{1
" Hacky method of avoiding the costly evaluation foldexpr on every
" keystroke by switching to manual folding for most of the time (folds
" will /not/ be updated) and update all folds after a certain idle
" period (see updatetime above).
function! SwitchFoldmethod()
    echomsg "Switching to expression-based folding."
    set foldmethod=expr
    " update folds - necessary to kickstart reevaluation.
    normal! zx
    echomsg "Switching back to manual folding."
    set foldmethod=manual
endfunction
" }}}1

" JumpToTargetID {{{1
" Implements a interlinking feature for Vimoutliner.  If you are on
" a line containing [> string], cursor positioned inside the brackets,
" then calling this function will jump to the (nearest) occurence of
" [string].  Really simple but rather effective.
function! JumpToTargetID()
    " TODO 2011-09-05, Add ability to wrap around newlines!  See VIM's
    " '\_' modifier.
    let l:line    = getline('.')
    let l:pattern = '\m\[-\?>\s\+\([^\[\]]\+\)\]'
    let l:links   = [[]]
    let l:timeout = 1000

    " Find all occurences of pattern in string and note their position.
    let l:i = 1
    while l:i
        let l:begin = match(l:line, l:pattern, 0, l:i)
        if l:begin != -1
            let l:end    = matchend(l:line, l:pattern, 0, l:i)
            let l:id     = matchstr(l:line, l:pattern, 0, l:i)
            let l:target = substitute(l:id, l:pattern, '\\\[\1\\\]', '')
            let l:links += [[ l:begin, l:end, target ]]
            let l:i += 1
        else
            break
        endif
    endwhile

    " If the list is still empty, quit now.
    if l:links == [[]]
        echo "No ID found on this line."
        return
    else
        call remove(l:links, 0)
    endif

    " Check whether the cursor is placed inside of one of the links and
    " jump there if so.
    let cursorpos = getpos(".")[2]
    for l:link in l:links
        if index(range(l:link[0]+1, l:link[1]), cursorpos) != -1
            " 2010-03-24, Don't need setpos(), search() itsself already
            " sets the cursor (parameter 's' sets  a jump mark)!
            if search(l:link[2], 'sw', 0, l:timeout) == 0
                echo "Target ID not found!"
            endif
            return
        endif
    endfor

    " If the cursor's positioned elsewhere, use the last jumpID.
    if search(l:links[-1][2], 'sw', 0, l:timeout) == 0
        echo "Target ID not found!"
    endif
endfunction

" vim:ft=vim:foldmethod=marker
